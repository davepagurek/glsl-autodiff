import { Op, OpLiteral, ADBase, Param, Input, ADConstructor } from './base';
export interface VecOp extends Op {
    x(): Op;
    y(): Op;
    z(): Op;
    w(): Op;
    definition(): string;
    derivative(param: Param): string;
    size(): number;
}
export declare class VecElementRef extends Op {
    prop: string;
    constructor(ad: ADBase, prop: string, vec: VecOp);
    definition(): string;
    derivative(param: Param): string;
}
export declare class VecParamElementRef extends OpLiteral {
    prop: string;
    name: string;
    constructor(ad: ADBase, prop: string, vec: VecOp);
    definition(): string;
    derivative(param: Param): "0.0" | "1.0";
}
export declare function Cache(target: Object, propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor;
export declare abstract class VectorOp extends Op {
    scalar(): boolean;
    abstract size(): number;
    initializer(): string;
    derivInitializer(param: Param): string;
    x(): Op;
    y(): Op;
    z(): Op;
    w(): Op;
    getVecElementRef(el: string): Op;
    u(): Op;
    v(): Op;
    r(): Op;
    g(): Op;
    b(): Op;
    a(): Op;
    xyzw(): Vec;
    xywz(): Vec;
    xzyw(): Vec;
    xzwy(): Vec;
    xwyz(): Vec;
    xwzy(): Vec;
    yxzw(): Vec;
    yxwz(): Vec;
    yzxw(): Vec;
    yzwx(): Vec;
    ywxz(): Vec;
    ywzx(): Vec;
    zxyw(): Vec;
    zxwy(): Vec;
    zyxw(): Vec;
    zywx(): Vec;
    zwxy(): Vec;
    zwyx(): Vec;
    wxyz(): Vec;
    wxzy(): Vec;
    wyxz(): Vec;
    wyzx(): Vec;
    wzxy(): Vec;
    wzyx(): Vec;
    xyz(): Vec;
    xzy(): Vec;
    yxz(): Vec;
    yzx(): Vec;
    zxy(): Vec;
    zyx(): Vec;
    xyw(): Vec;
    xwy(): Vec;
    yxw(): Vec;
    ywx(): Vec;
    wxy(): Vec;
    wyx(): Vec;
    xy(): Vec;
    yx(): Vec;
    xzw(): Vec;
    xwz(): Vec;
    zxw(): Vec;
    zwx(): Vec;
    wxz(): Vec;
    wzx(): Vec;
    xz(): Vec;
    zx(): Vec;
    xw(): Vec;
    wx(): Vec;
    yzw(): Vec;
    ywz(): Vec;
    zyw(): Vec;
    zwy(): Vec;
    wyz(): Vec;
    wzy(): Vec;
    yz(): Vec;
    zy(): Vec;
    yw(): Vec;
    wy(): Vec;
    zw(): Vec;
    wz(): Vec;
    rgba(): Vec;
    rgab(): Vec;
    rbga(): Vec;
    rbag(): Vec;
    ragb(): Vec;
    rabg(): Vec;
    grba(): Vec;
    grab(): Vec;
    gbra(): Vec;
    gbar(): Vec;
    garb(): Vec;
    gabr(): Vec;
    brga(): Vec;
    brag(): Vec;
    bgra(): Vec;
    bgar(): Vec;
    barg(): Vec;
    bagr(): Vec;
    argb(): Vec;
    arbg(): Vec;
    agrb(): Vec;
    agbr(): Vec;
    abrg(): Vec;
    abgr(): Vec;
    rgb(): Vec;
    rbg(): Vec;
    grb(): Vec;
    gbr(): Vec;
    brg(): Vec;
    bgr(): Vec;
    rga(): Vec;
    rag(): Vec;
    gra(): Vec;
    gar(): Vec;
    arg(): Vec;
    agr(): Vec;
    rg(): Vec;
    gr(): Vec;
    rba(): Vec;
    rab(): Vec;
    bra(): Vec;
    bar(): Vec;
    arb(): Vec;
    abr(): Vec;
    rb(): Vec;
    br(): Vec;
    ra(): Vec;
    ar(): Vec;
    gba(): Vec;
    gab(): Vec;
    bga(): Vec;
    bag(): Vec;
    agb(): Vec;
    abg(): Vec;
    gb(): Vec;
    bg(): Vec;
    ga(): Vec;
    ag(): Vec;
    ba(): Vec;
    ab(): Vec;
    uv(): Vec;
    vu(): Vec;
}
export declare abstract class WithVecDependencies extends VectorOp {
    get vecDependsOn(): VecOp[];
    size(): number;
}
export declare class Vec extends VectorOp {
    size(): number;
    definition(): string;
    derivative(param: Param): string;
    x(): Op;
    y(): Op;
    z(): Op;
    w(): Op;
}
export declare class VecParam extends VectorOp {
    private name;
    private _size;
    size(): number;
    constructor(ad: ADBase, name: string, size: number);
    x(): Op;
    y(): Op;
    z(): Op;
    w(): Op;
    private getElems;
    definition(): string;
    derivative(param: Param): string;
    initializer(): string;
    ref(): string;
    derivInitializer(param: Param): string;
}
export declare function WithVecBase<T extends ADConstructor>(Base: T): {
    new (...args: any[]): {
        vec2Param(name: string): VecParam;
        vec3Param(name: string): VecParam;
        vec4Param(name: string): VecParam;
        vec2(x: Input, y: Input): Vec;
        vec3(x: Input, y: Input, z: Input): Vec;
        vec4(x: Input, y: Input, z: Input, w: Input): Vec;
        getNextID(): number;
        val(n: number): import("./base").Value;
        registerParam(param: Op, name: string): any;
        param(name: string): Param;
        convertVal(param: Input): Op;
        convertVals(params: Input[]): Op[];
        output(name: string, op: Op): ADBase;
        outputDeriv(name: string, param: string | Param, op: Op): ADBase;
    };
} & T;
